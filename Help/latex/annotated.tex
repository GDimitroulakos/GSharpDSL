\section{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\hyperlink{class_graph_library_1_1_generics_1_1_abstract_graph_algorithm}{Graph\+Library.\+Generics.\+Abstract\+Graph\+Algorithm$<$ T, T\+Node, T\+Edge, T\+Graph $>$} \\*The abstract base class of the algorithms applied on graphs }{\pageref{class_graph_library_1_1_generics_1_1_abstract_graph_algorithm}}{}
\item\contentsline{section}{\hyperlink{class_graph_library_1_1_generics_1_1_abstract_graph_iterator}{Graph\+Library.\+Generics.\+Abstract\+Graph\+Iterator$<$ T $>$} \\*This class is the base abstract class of Graph\+Iterators. It has no implementation except from the m\+\_\+current\+Item member variable. This variable always point to the current element (which has type T) that the iterator points. The class\textquotesingle{}s methods are executed in a specific sequence that is dictated by the loop statement semantics that is \hyperlink{class_graph_library_1_1_generics_1_1_abstract_graph_iterator_a2c97c7a412c233b8442b7ad403f29779}{Begin()}, \hyperlink{class_graph_library_1_1_generics_1_1_abstract_graph_iterator_aa8cd9f596ec0b6c4c1e9c244ba75df04}{End()}, L\+O\+O\+P\+\_\+\+B\+O\+D\+Y, \hyperlink{class_graph_library_1_1_generics_1_1_abstract_graph_iterator_aac8cffd0d579708a94ba056e4f4a00b2}{Next()}, \hyperlink{class_graph_library_1_1_generics_1_1_abstract_graph_iterator_aa8cd9f596ec0b6c4c1e9c244ba75df04}{End()}, L\+O\+O\+P\+\_\+\+B\+O\+D\+Y, \hyperlink{class_graph_library_1_1_generics_1_1_abstract_graph_iterator_aac8cffd0d579708a94ba056e4f4a00b2}{Next()}, \hyperlink{class_graph_library_1_1_generics_1_1_abstract_graph_iterator_aa8cd9f596ec0b6c4c1e9c244ba75df04}{End()}, L\+O\+O\+P\+\_\+\+B\+O\+D\+Y, \hyperlink{class_graph_library_1_1_generics_1_1_abstract_graph_iterator_aac8cffd0d579708a94ba056e4f4a00b2}{Next()}, \hyperlink{class_graph_library_1_1_generics_1_1_abstract_graph_iterator_aa8cd9f596ec0b6c4c1e9c244ba75df04}{End()}... etc }{\pageref{class_graph_library_1_1_generics_1_1_abstract_graph_iterator}}{}
\item\contentsline{section}{\hyperlink{class_graph_library_1_1_generics_1_1_abstract_graph_iterator_factory}{Graph\+Library.\+Generics.\+Abstract\+Graph\+Iterator\+Factory$<$ T\+Node, T\+Edge, T\+Graph $>$} \\*This class is for programmers convinience. It instanciates iterators that iterate over a graph\textquotesingle{}s elements required for the algorithms and other graph processing facilities }{\pageref{class_graph_library_1_1_generics_1_1_abstract_graph_iterator_factory}}{}
\item\contentsline{section}{\hyperlink{class_graph_library_1_1_generics_1_1_abstract_graph_labeling}{Graph\+Library.\+Generics.\+Abstract\+Graph\+Labeling$<$ T\+Element $>$} \\*This class holds the labels for a specific type of elements (edge , nodes, graphs ) of a graph. I use two dictionaries for both mapping to gain in query speed. This class gives the opportunity that diffrent graph clients can assign diffrent labels to the graph nodes, edges etc. The graph client ( contructor ) creates a subclass of \hyperlink{class_graph_library_1_1_generics_1_1_abstract_graph_labeling}{Abstract\+Graph\+Labeling$<$\+T$>$} and assigns labels to nodes. The instance of this class exists inside the \hyperlink{class_graph_library_1_1_c_graph}{C\+Graph} class and the client can add a new labeling of graph elements through the Add\+Graph\+Node\+Labelling() method. }{\pageref{class_graph_library_1_1_generics_1_1_abstract_graph_labeling}}{}
\item\contentsline{section}{\hyperlink{class_graph_library_1_1_generics_1_1_abstract_graph_printer}{Graph\+Library.\+Generics.\+Abstract\+Graph\+Printer$<$ T\+Graph $>$} \\*This class is the parent class of all classes that print \hyperlink{class_graph_library_1_1_c_graph}{C\+Graph} objects Hence the class know the interface of \hyperlink{class_graph_library_1_1_c_graph}{C\+Graph}. (Its build for \hyperlink{class_graph_library_1_1_c_graph}{C\+Graph}). This class heirarchy is based on the Builder design pattern. }{\pageref{class_graph_library_1_1_generics_1_1_abstract_graph_printer}}{}
\item\contentsline{section}{\hyperlink{class_graph_library_1_1_generics_1_1_abstract_graph_query_info}{Graph\+Library.\+Generics.\+Abstract\+Graph\+Query\+Info$<$ Node, Edge, Graph $>$} \\*The purpose of this class is to simplify the expressions that the designer should write to access graph information from the code that describes the algorithm. This way the code that describes the algorithm is described with minimal complexity expressions something necessery to make him easily readapt to the code after long periods of abstention from this framework The class provides general access (takes object and returns object) to the node/edge information and requires casting to specialize it. }{\pageref{class_graph_library_1_1_generics_1_1_abstract_graph_query_info}}{}
\item\contentsline{section}{\hyperlink{class_graph_library_1_1_c_graph}{Graph\+Library.\+C\+Graph} \\*The Graph holds the list of nodes and the list of edges as well as the type of graph ( directed / undirected ) }{\pageref{class_graph_library_1_1_c_graph}}{}
\item\contentsline{section}{\hyperlink{class_graph_library_1_1_c_graph_algorithm}{Graph\+Library.\+C\+Graph\+Algorithm$<$ T $>$} \\*This is an abstract class that represents algorithms that run on graphs with the following types of elements 1) \hyperlink{class_graph_library_1_1_c_graph_node}{C\+Graph\+Node} for nodes 2) \hyperlink{class_graph_library_1_1_c_graph_edge}{C\+Graph\+Edge} for edges 3) \hyperlink{class_graph_library_1_1_c_graph}{C\+Graph} for graphs }{\pageref{class_graph_library_1_1_c_graph_algorithm}}{}
\item\contentsline{section}{\hyperlink{class_graph_library_1_1_c_graph_edge}{Graph\+Library.\+C\+Graph\+Edge} \\*A graph edges interconnects to Nodes ports that in sequence belong to a node The \hyperlink{class_graph_library_1_1_c_graph_edge}{C\+Graph\+Edge} class stores a reference to the source and target ports. And can provide through properties the source and target ports and nodes. It also provides given the port or node at the one side of the edge the corresponding port or node at the side. }{\pageref{class_graph_library_1_1_c_graph_edge}}{}
\item\contentsline{section}{\hyperlink{class_graph_library_1_1_c_graph_iterators_factory}{Graph\+Library.\+C\+Graph\+Iterators\+Factory} }{\pageref{class_graph_library_1_1_c_graph_iterators_factory}}{}
\item\contentsline{section}{\hyperlink{class_graph_library_1_1_c_graph_labeling}{Graph\+Library.\+C\+Graph\+Labeling$<$ T $>$} \\*This class provides general graph labelling capabilities. It doesn\textquotesingle{}t follow a specific strategy to label nodes/edges. It just implements the default version of Set\+Label methods for the class \hyperlink{class_graph_library_1_1_c_graph}{C\+Graph}. (This class is specific to \hyperlink{class_graph_library_1_1_c_graph}{C\+Graph} class) }{\pageref{class_graph_library_1_1_c_graph_labeling}}{}
\item\contentsline{section}{\hyperlink{class_graph_library_1_1_c_graph_node}{Graph\+Library.\+C\+Graph\+Node} \\*Represents a graph node . }{\pageref{class_graph_library_1_1_c_graph_node}}{}
\item\contentsline{section}{\hyperlink{class_graph_library_1_1_c_graph_printer}{Graph\+Library.\+C\+Graph\+Printer} \\*This class is the parent class of all classes that print \hyperlink{class_graph_library_1_1_c_graph}{C\+Graph} objects Hence the class know the interface of \hyperlink{class_graph_library_1_1_c_graph}{C\+Graph}. (Its build for \hyperlink{class_graph_library_1_1_c_graph}{C\+Graph}). This class heirarchy is based on the Builder design pattern. }{\pageref{class_graph_library_1_1_c_graph_printer}}{}
\item\contentsline{section}{\hyperlink{class_graph_library_1_1_c_graph_query_info}{Graph\+Library.\+C\+Graph\+Query\+Info} \\*Query info from the \hyperlink{class_graph_library_1_1_c_graph}{C\+Graph} class }{\pageref{class_graph_library_1_1_c_graph_query_info}}{}
\item\contentsline{section}{\hyperlink{class_graph_library_1_1_c_graph_viz_printer}{Graph\+Library.\+C\+Graph\+Viz\+Printer} \\*This class exports the graph in graphviz form. It accepts the graph and optionally a class that defined the labelling of nodes. If the client doen\textquotesingle{}t provide a labelling class a default class (Graph\+Viz\+Node\+Labeling) takes over the labelling of nodes }{\pageref{class_graph_library_1_1_c_graph_viz_printer}}{}
\item\contentsline{section}{\hyperlink{class_graph_library_1_1_c_it___graph_b_f_s}{Graph\+Library.\+C\+It\+\_\+\+Graph\+B\+F\+S} \\*Iterates over the nodes of a graph using Breadth First Traversal The graph can be directed or undirected }{\pageref{class_graph_library_1_1_c_it___graph_b_f_s}}{}
\item\contentsline{section}{\hyperlink{class_graph_library_1_1_c_it___graph_d_f_s}{Graph\+Library.\+C\+It\+\_\+\+Graph\+D\+F\+S} \\*Iterates over the nodes of a graph using Depth First Traversal The graph can be directed or undirected }{\pageref{class_graph_library_1_1_c_it___graph_d_f_s}}{}
\item\contentsline{section}{\hyperlink{class_graph_library_1_1_c_it___graph_edges}{Graph\+Library.\+C\+It\+\_\+\+Graph\+Edges} \\*Iterates over the graph edges }{\pageref{class_graph_library_1_1_c_it___graph_edges}}{}
\item\contentsline{section}{\hyperlink{class_graph_library_1_1_c_it___graph_leaf_nodes}{Graph\+Library.\+C\+It\+\_\+\+Graph\+Leaf\+Nodes} \\*Iterates over the graph\textquotesingle{}s nodes not having successors }{\pageref{class_graph_library_1_1_c_it___graph_leaf_nodes}}{}
\item\contentsline{section}{\hyperlink{class_graph_library_1_1_c_it___graph_nodes}{Graph\+Library.\+C\+It\+\_\+\+Graph\+Nodes} \\*Iterates over the graph nodes }{\pageref{class_graph_library_1_1_c_it___graph_nodes}}{}
\item\contentsline{section}{\hyperlink{class_graph_library_1_1_c_it___graph_root_nodes}{Graph\+Library.\+C\+It\+\_\+\+Graph\+Root\+Nodes} \\*Iterates over the graph\textquotesingle{}s nodes not having predecessors }{\pageref{class_graph_library_1_1_c_it___graph_root_nodes}}{}
\item\contentsline{section}{\hyperlink{class_graph_library_1_1_c_it___predecessors}{Graph\+Library.\+C\+It\+\_\+\+Predecessors} \\*Iterates over the predecessor nodes of a node }{\pageref{class_graph_library_1_1_c_it___predecessors}}{}
\item\contentsline{section}{\hyperlink{class_graph_library_1_1_c_it___successors}{Graph\+Library.\+C\+It\+\_\+\+Successors} \\*Iterates over the native successor nodes of a node }{\pageref{class_graph_library_1_1_c_it___successors}}{}
\item\contentsline{section}{\hyperlink{class_graph_library_1_1_aglorithms_1_1_edge_info___d_f_s}{Graph\+Library.\+Aglorithms.\+Edge\+Info\+\_\+\+D\+F\+S} \\*Graph edge info to assist the algorithm. There is an instance of the Info\+\_\+\+D\+F\+S class in each graph node }{\pageref{class_graph_library_1_1_aglorithms_1_1_edge_info___d_f_s}}{}
\item\contentsline{section}{\hyperlink{class_graph_library_1_1_aglorithms_1_1_g_alg___edge_oriented_d_f_s}{Graph\+Library.\+Aglorithms.\+G\+Alg\+\_\+\+Edge\+Oriented\+D\+F\+S} \\*This algorithm ( visitor ) performs a D\+F\+S traversal over a graph (directed or undirected ). It records the paths from which the algorithm passes by coloring nodes along them. The algorith works also for non-\/connected graphs 1) White (0) \+: Not yet visited 2) Gray (1) \+: Visited but not all of its neighbours 3) Black (2) \+: Visited and all of its neighbours }{\pageref{class_graph_library_1_1_aglorithms_1_1_g_alg___edge_oriented_d_f_s}}{}
\item\contentsline{section}{\hyperlink{class_graph_library_1_1_aglorithms_1_1_g_alg___node_oriented_d_f_s}{Graph\+Library.\+Aglorithms.\+G\+Alg\+\_\+\+Node\+Oriented\+D\+F\+S} \\*This algorithm ( visitor ) performs a D\+F\+S traversal over a graph (directed or undirected ). It records the paths from which the algorithm passes by coloring nodes along them. The algorith works also for non-\/connected graphs 1) White (0) \+: Not yet visited 2) Gray (1) \+: Visited but not all of its neighbours 3) Black (2) \+: Visited and all of its neighbours }{\pageref{class_graph_library_1_1_aglorithms_1_1_g_alg___node_oriented_d_f_s}}{}
\item\contentsline{section}{\hyperlink{class_graph_library_1_1_printers_1_1_graph_viz_printer_1_1_graph_viz_node_labeling}{Graph\+Library.\+Printers.\+Graph\+Viz\+Printer.\+Graph\+Viz\+Node\+Labeling} \\*Assign labels to nodes for graphviz printing }{\pageref{class_graph_library_1_1_printers_1_1_graph_viz_printer_1_1_graph_viz_node_labeling}}{}
\item\contentsline{section}{\hyperlink{interface_graph_library_1_1_generics_1_1_i_graph_algorithm}{Graph\+Library.\+Generics.\+I\+Graph\+Algorithm$<$ T, T\+Node $>$} \\*The interface represent the mandatory interface of the algorithm class. }{\pageref{interface_graph_library_1_1_generics_1_1_i_graph_algorithm}}{}
\item\contentsline{section}{\hyperlink{interface_graph_library_1_1_generics_1_1_i_graph_iterator}{Graph\+Library.\+Generics.\+I\+Graph\+Iterator$<$ T $>$} \\*Every iterator should implement the following interface. Look for more details in the \begin{DoxySeeAlso}{See also}
\hyperlink{class_graph_library_1_1_generics_1_1_abstract_graph_iterator}{Abstract\+Graph\+Iterator}


\end{DoxySeeAlso}
class }{\pageref{interface_graph_library_1_1_generics_1_1_i_graph_iterator}}{}
\item\contentsline{section}{\hyperlink{interface_graph_library_1_1_generics_1_1_i_graph_labeling}{Graph\+Library.\+Generics.\+I\+Graph\+Labeling$<$ T $>$} \\*Provides a generic interface for retrieving the label of a graph element of type T ( edge, node, whatever... ). Thus this class applies to all types of graph elements. }{\pageref{interface_graph_library_1_1_generics_1_1_i_graph_labeling}}{}
\item\contentsline{section}{\hyperlink{interface_graph_library_1_1_generics_1_1_i_graph_primitive}{Graph\+Library.\+Generics.\+I\+Graph\+Primitive} \\*This interface contains primitive operations common to any graph element ( node, edge, graph ) }{\pageref{interface_graph_library_1_1_generics_1_1_i_graph_primitive}}{}
\item\contentsline{section}{\hyperlink{class_graph_library_1_1_c_it___graph_b_f_s_1_1_info___d_f_s}{Graph\+Library.\+C\+It\+\_\+\+Graph\+B\+F\+S.\+Info\+\_\+\+D\+F\+S} \\*Graph node info to assist the iterator algorithm }{\pageref{class_graph_library_1_1_c_it___graph_b_f_s_1_1_info___d_f_s}}{}
\item\contentsline{section}{\hyperlink{class_graph_library_1_1_c_it___graph_d_f_s_1_1_info___d_f_s}{Graph\+Library.\+C\+It\+\_\+\+Graph\+D\+F\+S.\+Info\+\_\+\+D\+F\+S} \\*Graph node info to assist the iterator algorithm }{\pageref{class_graph_library_1_1_c_it___graph_d_f_s_1_1_info___d_f_s}}{}
\item\contentsline{section}{\hyperlink{class_graph_library_1_1_aglorithms_1_1_node_info___d_f_s}{Graph\+Library.\+Aglorithms.\+Node\+Info\+\_\+\+D\+F\+S} \\*Graph node info to assist the algorithm. Only the algorithm has access to the type of the Info\+\_\+\+D\+F\+S class. There could be also puclic Info class if the information is shared between diffrent algorithms. There is an instance of the Info\+\_\+\+D\+F\+S class in each graph node }{\pageref{class_graph_library_1_1_aglorithms_1_1_node_info___d_f_s}}{}
\end{DoxyCompactList}
